module main;
import closures;
import std::io;
import std::os::posix;
import std::os::backtrace;
import libc;

fn int add3(int a, int b, int c)
{
	io::printfn("%s + %s + %s = %s", a, b, c, a + b + c);
	return a + b + c;
}

alias IntFn = fn int(int);
alias VoidFn = fn void();

fn void print_something(void* dat) @nostrip @extern("print_something")// @naked
{
	io::printn("abc");
	io::printfn("Hello from assembly: %p", dat);
}

fn void print_something_else(void* dat) @nostrip
{
	io::printfn("Hello Again!: %p", dat);
}

fn String print(String fmt, int i)
{
	io::printfn(fmt, i);
	return string::tformat(fmt, i);
}

// TODO: this is two slightly different bugs. one with `movl [c], $eax` and one with `movl c, $eax;`
/*fn int test1(int, int) @nostrip
{
	int a, b;
	/*asm
	{
		movl $eax, [$rbp - 4];
		movl a, $eax;
		movl $eax, [$rbp - 8];
		movl b, $eax;
	}*/
	/*io::printfn("a: %p, b: %p", &a, &b);
	io::printfn("a: %s, b: %s", a, b);*/
	// asm("ret");
	a = 123;
	defer
	{
		int c;
		asm
		{
			movl [c], $eax;
		};
		io::printfn("returned %s", c);
	}
	return self(a);// @noinline;
/*	asm
	(`
		popq %r11;
		jmpq *%r11;
	`);*/
}*/

fn int self(int a) => a;

alias IntString = fn String(int);
// TODO: pass parameters directly as they are, but also push the saved parameter to the stack/an unused register and restore it in the function generated by the macro
// TODO: write down issues/wants with inline assembly blocks (and strings). trying to rewrite the current assembly string in an assembly block should give a good idea.
//       1: be able to take the address of labels
//       2: be able to take the address of local variables
//       3: more instructions (jmp, call, etc)
fn int main(String[] args)
{
	//io::printfn("a: %s", test1(12345, 67890));
	//io::printfn("a");
	closures::init()!!;
	defer closures::deinit();


	int a = 1;
	var fmt @safeinfer = closure::new(fn String(int a, usz b, String c) => string::tformat("a: %s, b: %s, c: %s", a, b, c), &a);
	defer closure::free(fmt);
	io::printn(fmt(1, "hello"));
	a = 4;
	var fmt1 @safeinfer = closure::new(fmt, &&1234ul);
	io::printn(fmt1("world!"));
	closure::free(fmt1);
	IntFn add1 = closure::new(&add3, &&1, &&2);
	io::printn(add1(3));
	closure::free(add1);

	return 0;
}

